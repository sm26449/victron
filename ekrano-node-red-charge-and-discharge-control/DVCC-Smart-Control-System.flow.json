[
    {
        "id": "dvcc_control_group",
        "type": "group",
        "z": "fbae6d16d556cf55",
        "name": "5. DVCC Smart Control System",
        "style": {
            "stroke": "#00ff00",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "dvcc_timer",
            "dvcc_calculator",
            "dvcc_monitor",
            "dvcc_history",
            "bda7914ee2c16e1f",
            "86faba0f81c2f696",
            "dvcc_safety_check"
        ],
        "x": 54,
        "y": 939,
        "w": 1212,
        "h": 202
    },
    {
        "id": "dvcc_timer",
        "type": "inject",
        "z": "fbae6d16d556cf55",
        "g": "dvcc_control_group",
        "name": "30sec Trigger",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "10",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "dvcc_control",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 1100,
        "wires": [
            [
                "dvcc_calculator"
            ]
        ]
    },
    {
        "id": "dvcc_calculator",
        "type": "function",
        "z": "fbae6d16d556cf55",
        "g": "dvcc_control_group",
        "name": "DVCC Smart Control",
        "func": "// Funcție Control DVCC Smart Charging cu optimizare bazată pe forecast\n// Versiune modificată pentru ZERO EXPORT la deficit energetic\n// Această funcție rulează la fiecare 30 secunde\n\n// === 1. CITIRE DATE GLOBALE ===\nconst battery = global.get('battery_data') || {};\nconst solarPower = global.get('solar_data_power') || {};\nconst solarCapacity = global.get('solar_data_capacity') || {};\nconst gridData = global.get('solar_data') || {};\nconst forecastKwh = global.get('solar_forecast_kwh') || 0;\n\n// === 2. CONSTANTE SISTEM ===\nconst MAX_CHARGE_CURRENT = 350; // Amperi maximi permisi\nconst MIN_CHARGE_CURRENT = 10;  // Curent minim de încărcare\nconst FLOAT_CHARGE_CURRENT = 15; // Curent pentru float charging (98-100%)\nconst BATTERY_NOMINAL_VOLTAGE = 51.2; // Tensiune nominală baterie LiFePO4\nconst EFFICIENCY = 0.95; // Eficiență încărcare\nconst RAMP_RATE = 10; // A/step - rata de creștere graduală\nconst SAFETY_MARGIN = 1.15; // Marjă de siguranță 15% pentru forecast\nconst CRITICAL_CONSUMPTION = 500; // W - consum critic minim care trebuie menținut\nconst MIN_PV_PRODUCTION = 500; // W - producție minimă pentru a începe încărcarea\n\n// Ferestre orare pentru optimizare\nconst now = new Date();\nconst currentHour = now.getHours() + now.getMinutes()/60;\nconst PEAK_START = 11.5;  // 11:30\nconst PEAK_END = 13.5;    // 13:30\nconst MORNING_START = 7;\nconst EVENING_END = 18;\nconst SUNSET_BUFFER = 17; // Ora până când vrem bateria plină\n\n// === 3. CITIRE DATE SISTEM REAL-TIME ===\nconst pvProduction = solarPower.totalPower || 0;\nconst gridPower = gridData.gridPower || 0; // Pozitiv = import, Negativ = export\nconst gridExport = gridPower < 0 ? Math.abs(gridPower) : 0; // Export actual în W\nconst gridImport = gridPower > 0 ? gridPower : 0; // Import actual în W\nconst batteryPower = (battery.current || 0) * (battery.voltage || BATTERY_NOMINAL_VOLTAGE);\nconst currentConsumption = pvProduction + gridImport - gridExport - batteryPower;\n\n// === 4. CALCUL ENERGIE NECESARĂ ȘI DISPONIBILĂ ===\nconst socPercent = battery.soc || 0;\nconst batteryVoltage = battery.voltage || BATTERY_NOMINAL_VOLTAGE;\nconst batteryCurrentNow = battery.current || 0; // Curent actual baterie\nconst energyNeededWh = battery.whNeeded || 0;\n\n// Calculăm energia deja produsă azi (bazat pe ora curentă)\nconst hoursSinceMorning = Math.max(0, currentHour - MORNING_START);\nconst totalProductionHours = EVENING_END - MORNING_START; // 11 ore total\nconst percentDayPassed = hoursSinceMorning / totalProductionHours;\nconst energyAlreadyProducedWh = forecastKwh * 1000 * percentDayPassed;\n\n// Calculăm energia rămasă de produs\nconst energyRemainingTodayWh = (forecastKwh * 1000) - energyAlreadyProducedWh;\n\n// Calculăm timpul rămas până la sunset buffer\nconst hoursUntilSunsetBuffer = Math.max(0, SUNSET_BUFFER - currentHour);\n\n// === 5. ANALIZĂ DEFICIT ENERGETIC ===\n// Calculăm deficitul real de energie\nconst energyDeficit = energyNeededWh - energyRemainingTodayWh;\nconst hasEnergyDeficit = energyDeficit > 0;\nconst deficitRatio = energyNeededWh > 0 ? (energyRemainingTodayWh / energyNeededWh) : 1;\n\n// Verificăm dacă energia rămasă este suficientă pentru încărcare completă\nconst energyBalance = energyRemainingTodayWh - (energyNeededWh * SAFETY_MARGIN);\nconst isForecastSufficient = energyBalance > 0;\n\n// Calculăm factorul de urgență (0 = mult timp rămas, 1 = urgență maximă)\nconst urgencyFactor = hoursUntilSunsetBuffer > 0 ? \n    1 - (hoursUntilSunsetBuffer / (SUNSET_BUFFER - MORNING_START)) : 1;\n\n// Calculăm raportul necesar/disponibil pentru ajustare dinamică\nconst energyRatio = energyNeededWh > 0 ? \n    (energyRemainingTodayWh / (energyNeededWh * SAFETY_MARGIN)) : 2;\n\n// === 6. FUNCȚIE HELPER PENTRU CALCUL PUTERE DISPONIBILĂ ===\nfunction getAvailableChargingPower() {\n    // Verificăm dacă avem producție\n    if (pvProduction <= 0) return 0;\n    \n    // Calculăm puterea disponibilă pentru încărcare\n    // Ținem cont de consumul critic care trebuie menținut\n    const netAvailable = pvProduction - CRITICAL_CONSUMPTION;\n    \n    // Dacă suntem sub consumul critic, nu putem încărca\n    if (netAvailable <= 0) return 0;\n    \n    // Returnăm puterea disponibilă\n    return netAvailable;\n}\n\n// === 7. VERIFICARE OVERRIDE MANUAL ===\nconst forceMaxCharge = global.get('force_max_charge') || false;\n\n// === 8. CALCUL CURENT ȚINTĂ DINAMIC ===\nlet targetChargeCurrent = 0;\nlet chargingStrategy = \"IDLE\";\nlet strategyReason = \"\";\n\n// Calculăm curentul necesar pentru a termina încărcarea la timp\nconst requiredAverageCurrent = hoursUntilSunsetBuffer > 0 ?\n    energyNeededWh / (batteryVoltage * hoursUntilSunsetBuffer * EFFICIENCY) : 0;\n\n// === CALCUL CURENT PENTRU ZERO EXPORT ===\n// Calculăm câți amperi în plus trebuie să adăugăm pentru a opri exportul\nconst exportCurrentEquivalent = gridExport / batteryVoltage; // Curent echivalent export\nconst currentChargeDeficit = exportCurrentEquivalent; // Cât trebuie să creștem pentru zero export\n\n// 8.1 Override manual are prioritate maximă\nif (forceMaxCharge && socPercent < 100) {\n    // Verificăm dacă avem producție pentru override\n    if (pvProduction > MIN_PV_PRODUCTION) {\n        targetChargeCurrent = MAX_CHARGE_CURRENT;\n        chargingStrategy = \"MANUAL_OVERRIDE\";\n        strategyReason = \"Manual override - Maximum charging forced\";\n    } else if (pvProduction > 0) {\n        // Avem ceva producție, dar nu suficientă pentru max\n        targetChargeCurrent = Math.min(\n            getAvailableChargingPower() / batteryVoltage,\n            MAX_CHARGE_CURRENT\n        );\n        chargingStrategy = \"MANUAL_LIMITED\";\n        strategyReason = `Manual override limited by PV (${pvProduction}W)`;\n    } else {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"MANUAL_NO_PV\";\n        strategyReason = \"Manual override blocked - No PV production\";\n    }\n    \n// 8.2 Verificări pentru stări speciale\n} else if (socPercent >= 98 && socPercent < 100) {\n    // Float charging pentru finalizare încărcare - doar dacă avem producție minimă\n    if (pvProduction >= FLOAT_CHARGE_CURRENT * batteryVoltage) {\n        targetChargeCurrent = FLOAT_CHARGE_CURRENT;\n        chargingStrategy = \"FLOAT\";\n        strategyReason = `Float charging to 100% (SOC: ${socPercent.toFixed(1)}%)`;\n    } else {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"FLOAT_WAITING\";\n        strategyReason = `Waiting for PV to complete float charge (${pvProduction}W)`;\n    }\n    \n} else if (socPercent >= 100) {\n    // Baterie complet încărcată\n    targetChargeCurrent = 0;\n    chargingStrategy = \"FULL\";\n    strategyReason = \"Battery fully charged (100%)\";\n    \n} else if (pvProduction <= 0) {\n    // NU avem deloc producție solară\n    targetChargeCurrent = 0;\n    chargingStrategy = \"NO_PRODUCTION\";\n    strategyReason = \"No PV production available\";\n    \n} else if (pvProduction < MIN_PV_PRODUCTION && pvProduction > 0) {\n    // Producție foarte mică - verificăm dacă merită să încărcăm\n    // Calculăm dacă producția acoperă măcar consumul critic\n    if (pvProduction > CRITICAL_CONSUMPTION && socPercent < 50) {\n        // Doar dacă SOC e mic și avem ceva surplus\n        const minimalCharge = Math.max(\n            MIN_CHARGE_CURRENT,\n            (pvProduction - CRITICAL_CONSUMPTION) / batteryVoltage\n        );\n        targetChargeCurrent = Math.min(minimalCharge, MIN_CHARGE_CURRENT * 2);\n        chargingStrategy = \"MINIMAL\";\n        strategyReason = `Minimal production (${pvProduction}W) - emergency charge at SOC ${socPercent.toFixed(1)}%`;\n    } else {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"IDLE_LOW_PV\";\n        strategyReason = `Insufficient PV production (${pvProduction}W < ${MIN_PV_PRODUCTION}W minimum)`;\n    }\n    \n} else if (currentHour < MORNING_START || currentHour >= EVENING_END) {\n    // În afara orelor de producție\n    targetChargeCurrent = 0;\n    chargingStrategy = \"NIGHT\";\n    strategyReason = \"Outside production hours\";\n    \n// 8.3 STRATEGII BAZATE PE DEFICIT ENERGETIC - doar cu producție suficientă\n} else if (hasEnergyDeficit && deficitRatio < 0.7) {\n    // === STRATEGIE CRITICĂ - Deficit major >30%, ZERO EXPORT ===\n    \n    // Verificăm întâi dacă avem producție disponibilă\n    const availablePower = getAvailableChargingPower();\n    \n    if (availablePower <= 0) {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"CRITICAL_DEFICIT_NO_POWER\";\n        strategyReason = `Critical deficit but no available power (PV: ${pvProduction}W, Consumption: ${CRITICAL_CONSUMPTION}W)`;\n    } else {\n        // CALCULĂM EXACT CÂT CURENT TREBUIE PENTRU ZERO EXPORT\n        const currentNeededForZeroExport = batteryCurrentNow + exportCurrentEquivalent + 5; // +5A marjă\n        \n        // Calculăm maximul teoretic disponibil\n        const maxAvailableCurrent = availablePower / batteryVoltage;\n        \n        // Verificăm dacă avem suficientă putere pentru a încărca\n        if (maxAvailableCurrent > MIN_CHARGE_CURRENT) {\n            targetChargeCurrent = Math.min(\n                Math.max(currentNeededForZeroExport, maxAvailableCurrent),\n                MAX_CHARGE_CURRENT\n            );\n            \n            // Dacă încă exportăm, creștem agresiv curentul\n            if (gridExport > 100 && pvProduction > gridExport) {\n                targetChargeCurrent = Math.min(\n                    batteryCurrentNow + (gridExport / batteryVoltage) + 10, // +10A marjă agresivă\n                    MAX_CHARGE_CURRENT\n                );\n            }\n            \n            chargingStrategy = \"CRITICAL_DEFICIT\";\n            strategyReason = `CRITICAL: ${(energyDeficit/1000).toFixed(1)}kWh deficit! ZERO EXPORT! Export blocked: ${(gridExport/1000).toFixed(1)}kW`;\n            \n            // Boost pentru SOC foarte scăzut\n            if (socPercent < 20) {\n                targetChargeCurrent = Math.min(targetChargeCurrent * 1.1, MAX_CHARGE_CURRENT);\n                strategyReason += \" | Ultra-low SOC boost\";\n            }\n            \n            // Log warning pentru situație critică\n            if (gridExport > 100) {\n                node.warn(`CRITICAL: Still exporting ${(gridExport/1000).toFixed(1)}kW with ${(energyDeficit/1000).toFixed(1)}kWh deficit! Increasing charge to ${targetChargeCurrent}A`);\n            }\n        } else {\n            targetChargeCurrent = 0;\n            chargingStrategy = \"CRITICAL_DEFICIT_LOW_POWER\";\n            strategyReason = `Critical deficit but insufficient available power (${(availablePower/1000).toFixed(1)}kW)`;\n        }\n    }\n    \n} else if (hasEnergyDeficit && deficitRatio < 0.85) {\n    // === STRATEGIE MAXIMĂ - Deficit 15-30%, ZERO EXPORT ===\n    \n    const availablePower = getAvailableChargingPower();\n    \n    if (availablePower <= MIN_CHARGE_CURRENT * batteryVoltage) {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"HIGH_DEFICIT_LOW_PV\";\n        strategyReason = `High deficit but low PV (${pvProduction}W)`;\n    } else {\n        // Similar, calculăm pentru zero export\n        const currentNeededForZeroExport = batteryCurrentNow + exportCurrentEquivalent + 3; // +3A marjă\n        const maxAvailableCurrent = (availablePower - currentConsumption * 0.2) / batteryVoltage;\n        \n        targetChargeCurrent = Math.min(\n            Math.max(currentNeededForZeroExport, maxAvailableCurrent),\n            MAX_CHARGE_CURRENT\n        );\n        \n        chargingStrategy = \"MAXIMUM_CHARGE\";\n        strategyReason = `High deficit: ${(energyDeficit/1000).toFixed(1)}kWh - Blocking export: ${(gridExport/1000).toFixed(1)}kW`;\n    }\n    \n} else if (hasEnergyDeficit && deficitRatio < 1.0) {\n    // === STRATEGIE AGRESIVĂ - Deficit mic <15%, minimizăm exportul ===\n    \n    const availablePower = getAvailableChargingPower();\n    \n    if (availablePower > MIN_CHARGE_CURRENT * batteryVoltage) {\n        const currentNeededForZeroExport = batteryCurrentNow + (exportCurrentEquivalent * 0.8); // Blocăm 80% din export\n        const availablePowerForCharging = Math.max(0, availablePower - (currentConsumption * 0.4));\n        \n        targetChargeCurrent = Math.min(\n            Math.max(currentNeededForZeroExport, availablePowerForCharging / batteryVoltage),\n            MAX_CHARGE_CURRENT\n        );\n        \n        chargingStrategy = \"AGGRESSIVE_DEFICIT\";\n        strategyReason = `Deficit ${(energyDeficit/1000).toFixed(1)}kWh - Reducing export`;\n    } else {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"DEFICIT_INSUFFICIENT_PV\";\n        strategyReason = `Deficit present but insufficient PV (${pvProduction}W)`;\n    }\n    \n} else if (!isForecastSufficient || energyRatio < 1.2) {\n    // === STRATEGIE AGRESIVĂ - Forecast insuficient (cu marjă de siguranță) ===\n    \n    const availablePower = getAvailableChargingPower();\n    \n    if (availablePower > MIN_CHARGE_CURRENT * batteryVoltage) {\n        // Încă blocăm exportul parțial\n        const currentNeededForReducedExport = batteryCurrentNow + (exportCurrentEquivalent * 0.6);\n        const availablePowerForCharging = Math.max(0, availablePower - (currentConsumption * 0.5));\n        \n        targetChargeCurrent = Math.min(\n            Math.max(currentNeededForReducedExport, availablePowerForCharging / batteryVoltage),\n            MAX_CHARGE_CURRENT\n        );\n        \n        if (currentHour >= PEAK_START && currentHour <= PEAK_END) {\n            chargingStrategy = \"AGGRESSIVE_PEAK\";\n            strategyReason = `Peak charging - forecast marginal, reducing export`;\n        } else {\n            chargingStrategy = \"AGGRESSIVE\";\n            strategyReason = `Aggressive charge - marginal forecast`;\n        }\n    } else {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"FORECAST_LOW_PV\";\n        strategyReason = `Marginal forecast but low PV (${pvProduction}W)`;\n    }\n    \n} else if (energyRatio > 1.5) {\n    // === STRATEGIE MODERATĂ - Avem surplus clar ===\n    \n    const availablePower = getAvailableChargingPower();\n    \n    if (availablePower > 0) {\n        const availablePowerForCharging = pvProduction - currentConsumption;\n        \n        if (currentHour >= PEAK_START && currentHour <= PEAK_END) {\n            targetChargeCurrent = Math.min(\n                Math.max(0, (availablePowerForCharging * 0.6) / batteryVoltage),\n                requiredAverageCurrent * 1.1\n            );\n            chargingStrategy = \"MODERATE_PEAK\";\n            strategyReason = `Surplus ${(energyBalance/1000).toFixed(1)}kWh - allowing export`;\n            \n        } else {\n            targetChargeCurrent = Math.min(\n                Math.max(0, (availablePowerForCharging * 0.5) / batteryVoltage),\n                requiredAverageCurrent\n            );\n            chargingStrategy = \"MODERATE\";\n            strategyReason = \"Surplus available - balanced charging\";\n        }\n    } else {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"SURPLUS_NO_POWER\";\n        strategyReason = `Surplus forecast but no available power`;\n    }\n    \n} else {\n    // === STRATEGIE BALANSATĂ - Forecast apropiat de necesar ===\n    \n    const availablePower = getAvailableChargingPower();\n    \n    if (availablePower > MIN_CHARGE_CURRENT * batteryVoltage) {\n        // Reducem exportul proporțional\n        const exportReductionFactor = Math.max(0, 1 - energyRatio);\n        const currentNeededForReducedExport = batteryCurrentNow + (exportCurrentEquivalent * exportReductionFactor);\n        \n        targetChargeCurrent = Math.min(\n            Math.max(currentNeededForReducedExport, requiredAverageCurrent),\n            MAX_CHARGE_CURRENT\n        );\n        \n        chargingStrategy = \"BALANCED\";\n        strategyReason = `Balanced strategy - partial export reduction`;\n    } else {\n        targetChargeCurrent = 0;\n        chargingStrategy = \"BALANCED_LOW_PV\";\n        strategyReason = `Balanced strategy blocked by low PV (${pvProduction}W)`;\n    }\n}\n\n// === 9. OVERRIDE PENTRU SOC CRITIC CU EXPORT ACTIV ===\n// Dacă SOC < 25% ȘI încă exportăm, forțăm oprirea exportului\nif (socPercent < 25 && gridExport > 100 && pvProduction > gridExport) {\n    const forceZeroExportCurrent = batteryCurrentNow + (gridExport / batteryVoltage) + 15; // +15A forțare\n    if (forceZeroExportCurrent > targetChargeCurrent && pvProduction > MIN_PV_PRODUCTION) {\n        targetChargeCurrent = Math.min(forceZeroExportCurrent, MAX_CHARGE_CURRENT);\n        chargingStrategy = \"CRITICAL_LOW_SOC\";\n        strategyReason = `FORCE ZERO EXPORT! SOC ${socPercent.toFixed(1)}% - Stopping ${(gridExport/1000).toFixed(1)}kW export`;\n        node.warn(`LOW SOC WARNING: ${socPercent}% with ${(gridExport/1000).toFixed(1)}kW export! Forcing charge to ${targetChargeCurrent}A`);\n    }\n}\n\n// === 10. AJUSTĂRI PENTRU TEMPERATURĂ ===\nconst batteryTemp = battery.temperature || 25;\nif (batteryTemp > 45) {\n    targetChargeCurrent *= 0.5;\n    strategyReason += \" | Temp >45°C: 50% reduction\";\n} else if (batteryTemp > 40) {\n    targetChargeCurrent *= 0.8;\n    strategyReason += \" | Temp >40°C: 20% reduction\";\n}\n\n// === 11. RAMPING ȘI LIMITĂRI ===\n// ELIMINĂM COMPLET RAMPING pentru situații cu export când avem deficit\nconst skipRamping = (hasEnergyDeficit && gridExport > 100) || \n                   chargingStrategy.includes(\"CRITICAL\") || \n                   chargingStrategy.includes(\"MAXIMUM\") ||\n                   chargingStrategy === \"MANUAL_OVERRIDE\" ||\n                   pvProduction <= 0; // Skip ramping și când nu avem producție\n\nif (!skipRamping && chargingStrategy !== \"FLOAT\" && chargingStrategy !== \"FULL\") {\n    // Aplicare ramping doar pentru situații non-critice\n    const lastChargeCurrent = global.get('last_charge_current') || 0;\n    const currentDiff = targetChargeCurrent - lastChargeCurrent;\n    \n    // Ramp mai agresiv când exportăm\n    const rampRate = gridExport > 500 ? RAMP_RATE * 2 : RAMP_RATE;\n    \n    if (Math.abs(currentDiff) > rampRate) {\n        if (currentDiff > 0) {\n            targetChargeCurrent = lastChargeCurrent + rampRate;\n            strategyReason += \" | Ramping up\";\n        } else {\n            targetChargeCurrent = lastChargeCurrent - rampRate;\n            strategyReason += \" | Ramping down\";\n        }\n    }\n}\n\n// === 12. VALIDĂRI FINALE ===\n// Verificare finală pentru producție disponibilă\nif (pvProduction <= 0 && targetChargeCurrent > 0) {\n    targetChargeCurrent = 0;\n    if (!chargingStrategy.includes(\"NO_\") && !chargingStrategy.includes(\"LOW_PV\")) {\n        chargingStrategy = \"BLOCKED_NO_PV\";\n        strategyReason = \"Charging blocked - no PV production\";\n    }\n}\n\n// Limitări finale\ntargetChargeCurrent = Math.min(targetChargeCurrent, MAX_CHARGE_CURRENT);\ntargetChargeCurrent = Math.max(0, targetChargeCurrent);\n\n// Valoare minimă pentru strategii care necesită încărcare\nif (targetChargeCurrent > 0 && targetChargeCurrent < MIN_CHARGE_CURRENT) {\n    if (!chargingStrategy.includes(\"MODERATE\") && !chargingStrategy.includes(\"BALANCED\") && !chargingStrategy.includes(\"MINIMAL\")) {\n        targetChargeCurrent = MIN_CHARGE_CURRENT;\n    } else {\n        targetChargeCurrent = 0; // Pentru moderate/balanced, oprim dacă e sub minim\n    }\n}\n\n// Rotunjire finală\ntargetChargeCurrent = Math.round(targetChargeCurrent);\n\n// === 13. VERIFICARE FINALĂ ANTI-EXPORT ===\n// Dacă încă avem deficit și export, forțăm creștere - dar DOAR dacă avem PV suficient\nif (hasEnergyDeficit && gridExport > 200 && targetChargeCurrent < MAX_CHARGE_CURRENT && pvProduction > gridExport) {\n    const emergencyBoost = Math.ceil(gridExport / batteryVoltage);\n    const maxPossibleCurrent = getAvailableChargingPower() / batteryVoltage;\n    \n    if (maxPossibleCurrent > targetChargeCurrent + emergencyBoost) {\n        targetChargeCurrent = Math.min(targetChargeCurrent + emergencyBoost, MAX_CHARGE_CURRENT);\n        strategyReason += ` | EMERGENCY: +${emergencyBoost}A to stop export`;\n        node.warn(`EMERGENCY BOOST: Adding ${emergencyBoost}A to stop ${(gridExport/1000).toFixed(1)}kW export`);\n    }\n}\n\n// === 14. SALVARE STARE ===\nglobal.set('last_charge_current', targetChargeCurrent);\nglobal.set('charging_strategy', {\n    strategy: chargingStrategy,\n    reason: strategyReason,\n    energyBalance: energyBalance,\n    energyRatio: energyRatio,\n    energyDeficit: energyDeficit,\n    deficitRatio: deficitRatio,\n    gridExport: gridExport,\n    pvProduction: pvProduction,\n    availablePower: getAvailableChargingPower(),\n    targetCurrent: targetChargeCurrent,\n    timestamp: Date.now()\n});\n\n// === 15. CALCULE MONITORING ===\nconst chargeRatePercent = (targetChargeCurrent / MAX_CHARGE_CURRENT * 100).toFixed(1);\nconst estimatedTimeToFull = targetChargeCurrent > 0 ? \n    (energyNeededWh / (targetChargeCurrent * batteryVoltage * EFFICIENCY)) : 0;\nconst pvUtilization = pvProduction > 0 ? \n    ((targetChargeCurrent * batteryVoltage) / pvProduction * 100) : 0;\nconst exportPrevented = hasEnergyDeficit ? gridExport : 0;\n\n// === 16. STATUS NOD ===\nconst statusColor = pvProduction <= 0 ? \"gray\" :\n                   chargingStrategy.includes(\"CRITICAL\") ? \"red\" :\n                   chargingStrategy.includes(\"MAXIMUM\") ? \"orange\" :\n                   chargingStrategy === \"FLOAT\" ? \"yellow\" :\n                   chargingStrategy === \"FULL\" ? \"blue\" :\n                   chargingStrategy.includes(\"AGGRESSIVE\") ? \"orange\" :\n                   chargingStrategy.includes(\"MODERATE\") ? \"green\" :\n                   chargingStrategy.includes(\"BALANCED\") ? \"green\" :\n                   chargingStrategy.includes(\"NO_\") ? \"gray\" :\n                   chargingStrategy.includes(\"LOW_PV\") ? \"gray\" :\n                   chargingStrategy === \"IDLE\" ? \"gray\" : \"blue\";\n\nconst pvStatus = pvProduction <= 0 ? \" | NO PV!\" : \n                pvProduction < MIN_PV_PRODUCTION ? ` | LOW PV: ${pvProduction}W` : \"\";\nconst exportStatus = gridExport > 100 ? ` | EXPORT: ${(gridExport/1000).toFixed(1)}kW!` : \"\";\n\nnode.status({\n    fill: statusColor,\n    shape: pvProduction <= 0 ? \"ring\" : \n           gridExport > 100 && hasEnergyDeficit ? \"ring\" : \"dot\",\n    text: `${chargingStrategy}: ${targetChargeCurrent}A | SOC: ${socPercent.toFixed(1)}%${pvStatus}${exportStatus}`\n});\n\n// === 17. OUTPUT ===\nmsg.payload = {\n    // Comandă DVCC\n    dvcc_charge_current: targetChargeCurrent,\n    \n    // Date sistem\n    system_state: {\n        battery_soc: socPercent,\n        battery_voltage: batteryVoltage,\n        battery_current: batteryCurrentNow,\n        battery_temp: batteryTemp,\n        pv_production: pvProduction,\n        pv_available_power: getAvailableChargingPower(),\n        grid_power: gridPower,\n        grid_export: gridExport,\n        grid_import: gridImport,\n        consumption: currentConsumption,\n        forecast_kwh: forecastKwh\n    },\n    \n    // Analiză energie\n    energy_analysis: {\n        energy_needed_wh: energyNeededWh,\n        energy_remaining_today_wh: energyRemainingTodayWh,\n        energy_balance_wh: energyBalance,\n        energy_deficit_wh: energyDeficit,\n        deficit_ratio: deficitRatio,\n        energy_ratio: energyRatio,\n        is_forecast_sufficient: isForecastSufficient,\n        has_energy_deficit: hasEnergyDeficit,\n        hours_until_target: hoursUntilSunsetBuffer,\n        export_current_equivalent: exportCurrentEquivalent,\n        available_charging_power_w: getAvailableChargingPower()\n    },\n    \n    // Strategie\n    charging_strategy: {\n        mode: chargingStrategy,\n        reason: strategyReason,\n        target_current: targetChargeCurrent,\n        current_adjustment: targetChargeCurrent - batteryCurrentNow,\n        required_avg_current: requiredAverageCurrent.toFixed(1),\n        charge_rate_percent: chargeRatePercent,\n        force_max_charge: forceMaxCharge,\n        ramping_skipped: skipRamping,\n        pv_sufficient: pvProduction >= MIN_PV_PRODUCTION\n    },\n    \n    // Estimări\n    estimates: {\n        time_to_full_hours: estimatedTimeToFull.toFixed(1),\n        energy_needed_kwh: (energyNeededWh / 1000).toFixed(2),\n        remaining_production_kwh: (energyRemainingTodayWh / 1000).toFixed(2),\n        deficit_kwh: hasEnergyDeficit ? (energyDeficit / 1000).toFixed(2) : 0,\n        pv_utilization_percent: pvUtilization.toFixed(1),\n        export_prevented_w: exportPrevented,\n        completion_time: estimatedTimeToFull > 0 ? \n            new Date(Date.now() + estimatedTimeToFull * 3600000).toLocaleTimeString() : \"N/A\"\n    },\n    \n    // Alerte\n    alerts: {\n        critical_deficit: hasEnergyDeficit && deficitRatio < 0.7,\n        high_deficit: hasEnergyDeficit && deficitRatio < 0.85,\n        low_soc_warning: socPercent < 25,\n        high_temp_warning: batteryTemp > 40,\n        export_with_deficit: hasEnergyDeficit && gridExport > 100,\n        emergency_boost_active: hasEnergyDeficit && gridExport > 200,\n        no_pv_production: pvProduction <= 0,\n        low_pv_production: pvProduction > 0 && pvProduction < MIN_PV_PRODUCTION,\n        no_pv_with_deficit: pvProduction <= 0 && hasEnergyDeficit,\n        low_pv_critical: pvProduction > 0 && pvProduction < MIN_PV_PRODUCTION && socPercent < 30\n    },\n    \n    // Export control\n    export_control: {\n        should_block_export: hasEnergyDeficit,\n        current_export_w: gridExport,\n        current_export_a: exportCurrentEquivalent,\n        additional_current_needed: gridExport > 100 ? exportCurrentEquivalent : 0,\n        export_blocked_successfully: gridExport < 100,\n        pv_allows_blocking: pvProduction > gridExport\n    },\n    \n    // PV status\n    pv_status: {\n        production_w: pvProduction,\n        available_for_charging_w: getAvailableChargingPower(),\n        meets_minimum_requirement: pvProduction >= MIN_PV_PRODUCTION,\n        critical_consumption_covered: pvProduction >= CRITICAL_CONSUMPTION,\n        can_charge: getAvailableChargingPower() > MIN_CHARGE_CURRENT * batteryVoltage\n    },\n    \n    timestamp: new Date().toISOString()\n};\n\n// Mesaj de alertă dacă exportăm cu deficit\nif (hasEnergyDeficit && gridExport > 500) {\n    msg.alert = {\n        severity: \"HIGH\",\n        message: `EXPORTING ${(gridExport/1000).toFixed(1)}kW WITH ${(energyDeficit/1000).toFixed(1)}kWh DEFICIT!`,\n        action: pvProduction > gridExport ? \n            `Increase charge current by ${Math.ceil(exportCurrentEquivalent)}A to stop export` :\n            `Insufficient PV (${pvProduction}W) to stop export completely`\n    };\n}\n\n// Alertă pentru lipsă producție cu necesar de încărcare\nif (pvProduction <= 0 && energyNeededWh > 1000) {\n    msg.warning = {\n        severity: \"MEDIUM\",\n        message: `No PV production with ${(energyNeededWh/1000).toFixed(1)}kWh needed for charging`,\n        action: \"Waiting for solar production to resume\"\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "// Inițializare variabile persistente\nglobal.set('last_charge_current', 0);\nglobal.set('dvcc_history', []);\nglobal.set('charge_session_data', {\n    started: Date.now(),\n    energy_charged: 0\n});",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 1100,
        "wires": [
            [
                "dvcc_monitor",
                "dvcc_history",
                "dvcc_safety_check"
            ]
        ]
    },
    {
        "id": "dvcc_monitor",
        "type": "function",
        "z": "fbae6d16d556cf55",
        "g": "dvcc_control_group",
        "name": "Performance Monitor",
        "func": "// Monitorizare performanță și eficiență\nconst data = msg.payload;\nconst perf = global.get('dvcc_performance') || {\n    total_energy_charged: 0,\n    session_start: Date.now(),\n    peak_current: 0,\n    average_current: 0,\n    samples: 0\n};\n\n// Actualizare statistici\nif (data.dvcc_charge_current > perf.peak_current) {\n    perf.peak_current = data.dvcc_charge_current;\n}\n\nperf.samples++;\nperf.average_current = ((perf.average_current * (perf.samples - 1)) + data.dvcc_charge_current) / perf.samples;\n\n// Estimare energie încărcată (Wh)\nconst energy_step = (data.dvcc_charge_current * data.system_state.battery_voltage * 10) / 3600; // 10 secunde\nperf.total_energy_charged += energy_step;\n\n// Calculează eficiența\nperf.efficiency = (perf.total_energy_charged / (data.system_state.pv_production * (Date.now() - perf.session_start) / 3600000)) * 100 || 0;\n\nglobal.set('dvcc_performance', perf);\n\n// Trimite date pentru dashboard\nmsg.performance = {\n    peak_current: perf.peak_current,\n    avg_current: perf.average_current.toFixed(1),\n    total_kwh: (perf.total_energy_charged / 1000).toFixed(2),\n    efficiency: perf.efficiency.toFixed(1)\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 1040,
        "wires": [
            []
        ]
    },
    {
        "id": "dvcc_history",
        "type": "function",
        "z": "fbae6d16d556cf55",
        "g": "dvcc_control_group",
        "name": "History Logger",
        "func": "// Salvează istoric pentru analiză\nconst history = global.get('dvcc_history') || [];\nconst maxHistory = 360; // 1 oră de date (la 10 sec/sample)\n\n// Adaugă intrare nouă\nhistory.push({\n    timestamp: Date.now(),\n    current: msg.payload.dvcc_charge_current,\n    soc: msg.payload.system_state.battery_soc,\n    pv: msg.payload.system_state.pv_production,\n    strategy: msg.payload.charging_strategy.mode\n});\n\n// Menține doar ultimele N intrări\nif (history.length > maxHistory) {\n    history.shift();\n}\n\nglobal.set('dvcc_history', history);\n\n// Calculează statistici pentru ultima oră\nif (history.length >= 60) { // Minim 10 minute de date\n    const stats = {\n        avg_current: history.reduce((sum, h) => sum + h.current, 0) / history.length,\n        max_current: Math.max(...history.map(h => h.current)),\n        min_current: Math.min(...history.map(h => h.current)),\n        soc_increase: history[history.length - 1].soc - history[0].soc,\n        strategies_used: [...new Set(history.map(h => h.strategy))]\n    };\n    \n    msg.hourly_stats = stats;\n    node.status({\n        text: `Avg: ${stats.avg_current.toFixed(0)}A | SOC +${stats.soc_increase.toFixed(1)}%`\n    });\n}\n\nreturn null; // Nu trimite mai departe, doar loghează",
        "outputs": 0,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 1100,
        "wires": []
    },
    {
        "id": "bda7914ee2c16e1f",
        "type": "victron-output-ess",
        "z": "fbae6d16d556cf55",
        "g": "dvcc_control_group",
        "service": "com.victronenergy.settings",
        "path": "/Settings/SystemSetup/MaxChargeCurrent",
        "serviceObj": {
            "service": "com.victronenergy.settings",
            "name": "Venus settings"
        },
        "pathObj": {
            "path": "/Settings/SystemSetup/MaxChargeCurrent",
            "type": "float",
            "name": "DVCC Charge current limit (A)",
            "mode": "both"
        },
        "name": "Set DVCC",
        "onlyChanges": false,
        "x": 1170,
        "y": 980,
        "wires": []
    },
    {
        "id": "86faba0f81c2f696",
        "type": "change",
        "z": "fbae6d16d556cf55",
        "g": "dvcc_control_group",
        "name": "DVCC Charge Current",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "payload.dvcc_charge_current",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 960,
        "y": 980,
        "wires": [
            [
                "bda7914ee2c16e1f"
            ]
        ]
    },
    {
        "id": "dvcc_safety_check",
        "type": "function",
        "z": "fbae6d16d556cf55",
        "g": "dvcc_control_group",
        "name": "Safety & Validation",
        "func": "// Verificări de siguranță finale pentru DVCC\nconst dvcc = msg.payload.dvcc_charge_current;\nconst battery = msg.payload.system_state || {};\n\n// Flag pentru oprire de siguranță\nlet safetyStop = false;\nlet safetyWarnings = [];\n\n// === DEFINIRE CONSTANTE LIMITE ===\n// Pentru LiFePO4 16S: \n// - Minim: 48V (3.0V/cell)\n// - Nominal: 51.2V (3.2V/cell)  \n// - Maxim: 58.4V (3.65V/cell)\nconst VOLTAGE_MIN = 46.0; // Cu marjă de siguranță\nconst VOLTAGE_MAX = 59.0; // Cu marjă pentru peak-uri\nconst VOLTAGE_NOMINAL = 51.2;\n\n// === SALVARE PERSISTENTĂ VALORI GLOBALE ===\nconst GLOBAL_KEY = 'dvcc_battery_state';\n\n// Funcție pentru a citi starea salvată\nfunction getStoredState() {\n    let stored = global.get(GLOBAL_KEY) || {};\n    // Validăm că avem o structură corectă\n    if (!stored.history) {\n        stored.history = [];\n    }\n    if (!stored.last_valid) {\n        stored.last_valid = {\n            voltage: VOLTAGE_NOMINAL,\n            temperature: 25,\n            soc: 50,\n            capacity: 2320,\n            timestamp: Date.now()\n        };\n    }\n    // Adăugăm tracking pentru ultima verificare rate of change\n    if (!stored.last_rate_check) {\n        stored.last_rate_check = {\n            voltage: VOLTAGE_NOMINAL,\n            temperature: 25,\n            timestamp: Date.now()\n        };\n    }\n    return stored;\n}\n\n// Funcție pentru a salva starea\nfunction saveState(voltage, temp, soc, capacity) {\n    let stored = getStoredState();\n    \n    // Salvăm valorile curente ca fiind ultimele valide\n    stored.last_valid = {\n        voltage: voltage || stored.last_valid.voltage,\n        temperature: temp || stored.last_valid.temperature,\n        soc: soc !== null ? soc : stored.last_valid.soc,\n        capacity: capacity || stored.last_valid.capacity,\n        timestamp: Date.now()\n    };\n    \n    // Păstrăm istoric pentru ultimele 10 citiri\n    stored.history.push({\n        voltage: voltage,\n        temperature: temp,\n        soc: soc,\n        timestamp: Date.now()\n    });\n    \n    // Limităm istoricul la ultimele 10 înregistrări\n    if (stored.history.length > 10) {\n        stored.history.shift();\n    }\n    \n    // Salvăm în global\n    global.set(GLOBAL_KEY, stored);\n    return stored;\n}\n\n// Citim starea anterioară salvată\nconst storedState = getStoredState();\n\n// === EXTRAGERE VALORI DIN SYSTEM_STATE ===\nlet batteryVoltage = battery.battery_voltage || battery.voltage || null;\nlet batteryTemp = battery.battery_temp || battery.temperature || null;\nlet soc = battery.battery_soc || battery.soc || null;\nlet capacity = battery.battery_capacity || battery.capacity || storedState.last_valid.capacity;\n\n// === VALIDARE TENSIUNE CU FILTRARE ZGOMOT ===\n// Dacă tensiunea lipsește sau e invalidă, folosim ultima valoare validă\nif (batteryVoltage === null || batteryVoltage === undefined) {\n    batteryVoltage = storedState.last_valid.voltage;\n    node.warn(\"Using stored voltage value: \" + batteryVoltage + \"V\");\n} else {\n    // Verificăm dacă tensiunea e în limite plauzibile\n    if (batteryVoltage < VOLTAGE_MIN || batteryVoltage > VOLTAGE_MAX) {\n        const lastValidVoltage = storedState.last_valid.voltage;\n        \n        // Verificăm dacă e o schimbare nerealistă (>5V diferență într-o singură citire)\n        if (Math.abs(batteryVoltage - lastValidVoltage) > 5) {\n            // Probabil eroare de citire - folosim valoarea anterioară\n            node.warn(`Voltage reading suspicious (${batteryVoltage}V), using stored: ${lastValidVoltage}V`);\n            batteryVoltage = lastValidVoltage;\n        } else if (batteryVoltage < VOLTAGE_MIN - 2 || batteryVoltage > VOLTAGE_MAX + 2) {\n            // Tensiune complet în afara limitelor - oprire de siguranță\n            msg.payload.dvcc_charge_current = 0;\n            safetyStop = true;\n            node.error(`Battery voltage critical: ${batteryVoltage}V`);\n            safetyWarnings.push(`Critical voltage: ${batteryVoltage.toFixed(2)}V`);\n        }\n    } else {\n        // Aplicăm un filtru de netezire pentru a reduce zgomotul\n        const lastValidVoltage = storedState.last_valid.voltage;\n        const voltageDiff = Math.abs(batteryVoltage - lastValidVoltage);\n        \n        // Pentru schimbări mici (<0.5V), aplicăm un filtru de medie\n        if (voltageDiff < 0.5 && lastValidVoltage > VOLTAGE_MIN) {\n            // Filtru exponențial pentru netezire\n            batteryVoltage = lastValidVoltage * 0.7 + batteryVoltage * 0.3;\n        }\n    }\n}\n\n// Folosim valorile salvate pentru temperatură dacă lipsesc\nif (batteryTemp === null || batteryTemp === undefined) {\n    batteryTemp = storedState.last_valid.temperature;\n    node.warn(\"Using stored temperature value: \" + batteryTemp + \"°C\");\n}\n\nif (soc === null || soc === undefined) {\n    soc = storedState.last_valid.soc;\n}\n\n// === 1. VERIFICARE LIMITE CURENT ===\nif (dvcc > 350) {\n    msg.payload.dvcc_charge_current = 350;\n    node.warn(\"DVCC current limited to 350A (safety limit)\");\n    safetyWarnings.push(\"Current limited to 350A\");\n}\n\n// === 2. VERIFICARE TENSIUNE PENTRU STADII DE ÎNCĂRCARE ===\nif (batteryVoltage > 57.6 && msg.payload.dvcc_charge_current > 100) {\n    // Aproape de tensiunea maximă, reducem curentul\n    msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 50);\n    safetyWarnings.push(`High voltage ${batteryVoltage.toFixed(2)}V, current limited to 50A`);\n}\n\n// === 3. VERIFICARE TEMPERATURĂ ===\n// Validare temperatură - verificăm dacă e în limite realiste\nif (batteryTemp > 60 || batteryTemp < -10) {\n    const lastValidTemp = storedState.last_valid.temperature;\n    node.warn(`Temperature suspicious (${batteryTemp}°C), using stored: ${lastValidTemp}°C`);\n    batteryTemp = lastValidTemp;\n}\n\n// Aplicare limite bazate pe temperatură\nif (batteryTemp > 55) {\n    msg.payload.dvcc_charge_current = 0;\n    safetyStop = true;\n    node.error(`Battery temperature critical: ${batteryTemp.toFixed(1)}°C! Charging stopped.`);\n    safetyWarnings.push(`Critical temperature: ${batteryTemp.toFixed(1)}°C`);\n} else if (batteryTemp > 45) {\n    msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 50);\n    node.warn(`Battery temperature high: ${batteryTemp.toFixed(1)}°C. Current limited to 50A`);\n    safetyWarnings.push(`High temperature: ${batteryTemp.toFixed(1)}°C, limited to 50A`);\n} else if (batteryTemp > 40) {\n    msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 150);\n    safetyWarnings.push(`Elevated temperature: ${batteryTemp.toFixed(1)}°C, limited to 150A`);\n} else if (batteryTemp < 0) {\n    msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 100);\n    node.warn(`Battery temperature low: ${batteryTemp.toFixed(1)}°C. Current limited to 100A`);\n    safetyWarnings.push(`Low temperature: ${batteryTemp.toFixed(1)}°C, limited to 100A`);\n} else if (batteryTemp < 5) {\n    msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 200);\n    safetyWarnings.push(`Cool temperature: ${batteryTemp.toFixed(1)}°C, limited to 200A`);\n}\n\n// === 4. VERIFICARE SOC ===\nif (soc >= 99.5) {\n    msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 20);\n    safetyWarnings.push(\"Battery at 99.5%, current limited to 20A\");\n} else if (soc >= 98) {\n    msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 50);\n    safetyWarnings.push(`SOC ${soc}%, finishing charge at 50A max`);\n} else if (soc >= 95) {\n    msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 100);\n    safetyWarnings.push(`SOC ${soc}%, current limited to 100A`);\n}\n\n// === 5. VERIFICARE RATE OF CHANGE OPTIMIZATĂ ===\n// Verificăm schimbările doar la intervale mai mari pentru a evita alarmele false\nconst currentTime = Date.now();\nconst timeSinceLastRateCheck = currentTime - storedState.last_rate_check.timestamp;\n\n// Verificăm rate of change doar după minimum 60 secunde (nu 10 secunde ca înainte)\nif (timeSinceLastRateCheck > 60000) { // 1 minut minimum\n    \n    // Verificare schimbare tensiune\n    if (storedState.last_rate_check.voltage && \n        batteryVoltage && \n        batteryVoltage > VOLTAGE_MIN && \n        batteryVoltage < VOLTAGE_MAX) {\n        \n        const voltageChange = Math.abs(batteryVoltage - storedState.last_rate_check.voltage);\n        const timeInMinutes = timeSinceLastRateCheck / 60000;\n        const voltageChangePerMinute = voltageChange / timeInMinutes;\n        \n        // Praguri mai relaxate și verificare doar pentru schimbări semnificative\n        // Pentru LiFePO4, ignorăm schimbări sub 2V/minut (mult mai relaxat)\n        if (voltageChangePerMinute > 2.0 && voltageChange > 2.0) {\n            // Verificăm dacă e într-adevăr o problemă (>3V/minut)\n            if (voltageChangePerMinute > 3.0) {\n                node.warn(`Significant voltage change: ${voltageChange.toFixed(2)}V in ${timeInMinutes.toFixed(1)} min`);\n                safetyWarnings.push(`High voltage rate: ${voltageChangePerMinute.toFixed(2)}V/min`);\n                msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, 100);\n            }\n        }\n    }\n    \n    // Verificare schimbare temperatură\n    if (storedState.last_rate_check.temperature && \n        batteryTemp && \n        batteryTemp > -10 && \n        batteryTemp < 60) {\n        \n        const tempChange = batteryTemp - storedState.last_rate_check.temperature;\n        const timeInMinutes = timeSinceLastRateCheck / 60000;\n        const tempChangePerMinute = tempChange / timeInMinutes;\n        \n        // Temperatura nu ar trebui să crească cu mai mult de 1°C/minut\n        if (tempChangePerMinute > 1.0) {\n            safetyWarnings.push(`Temperature rising: ${tempChangePerMinute.toFixed(1)}°C/min`);\n            const reductionFactor = Math.max(0.3, 1 - (tempChangePerMinute / 2));\n            msg.payload.dvcc_charge_current = Math.round(msg.payload.dvcc_charge_current * reductionFactor);\n        }\n    }\n    \n    // Actualizăm timpul și valorile pentru următoarea verificare rate of change\n    storedState.last_rate_check = {\n        voltage: batteryVoltage,\n        temperature: batteryTemp,\n        timestamp: currentTime\n    };\n    global.set(GLOBAL_KEY, storedState);\n}\n\n// Salvăm starea curentă doar dacă toate valorile sunt valide\nif (batteryVoltage > VOLTAGE_MIN && batteryVoltage < VOLTAGE_MAX &&\n    batteryTemp > -10 && batteryTemp < 60) {\n    saveState(batteryVoltage, batteryTemp, soc, capacity);\n}\n\n// === 6. VERIFICARE C-RATE ===\nif (capacity && capacity > 0) {\n    const cRate = msg.payload.dvcc_charge_current / capacity;\n    const maxCRate = 0.5; // 0.5C pentru longevitate maximă\n    \n    if (cRate > maxCRate) {\n        const maxCurrent = Math.round(capacity * maxCRate);\n        msg.payload.dvcc_charge_current = Math.min(msg.payload.dvcc_charge_current, maxCurrent);\n        safetyWarnings.push(`C-rate limited to ${maxCRate}C (${maxCurrent}A)`);\n    }\n}\n\n// === 7. VERIFICARE VALOARE FINALĂ ===\nmsg.payload.dvcc_charge_current = Math.max(0, Math.min(350, msg.payload.dvcc_charge_current));\nmsg.payload.dvcc_charge_current = Math.round(msg.payload.dvcc_charge_current);\n\n// === 8. ADĂUGARE INFORMAȚII DE SIGURANȚĂ LA PAYLOAD ===\nmsg.payload.safety_check = {\n    passed: !safetyStop,\n    warnings: safetyWarnings,\n    limits_applied: {\n        voltage: `${VOLTAGE_MIN}-${VOLTAGE_MAX}V`,\n        temperature: \"0-55°C\",\n        current: \"0-350A\",\n        c_rate: \"0.5C max\"\n    },\n    current_status: {\n        voltage: batteryVoltage ? `${batteryVoltage.toFixed(2)}V` : \"Unknown\",\n        temperature: batteryTemp ? `${batteryTemp.toFixed(1)}°C` : \"Unknown\",\n        soc: soc !== null ? `${soc.toFixed(1)}%` : \"Unknown\",\n        capacity: `${capacity}Ah`,\n        final_current: `${msg.payload.dvcc_charge_current}A`,\n        c_rate: capacity ? `${(msg.payload.dvcc_charge_current/capacity).toFixed(2)}C` : \"Unknown\"\n    },\n    validated_at: new Date().toISOString()\n};\n\n// Setare status nod\nif (safetyStop) {\n    node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: `STOP: ${safetyWarnings[0]}`\n    });\n} else if (safetyWarnings.length > 0) {\n    node.status({\n        fill: \"yellow\", \n        shape: \"dot\",\n        text: `${msg.payload.dvcc_charge_current}A (${safetyWarnings.length} limits)`\n    });\n} else {\n    node.status({\n        fill: \"green\",\n        shape: \"dot\",\n        text: `OK: ${msg.payload.dvcc_charge_current}A @ ${batteryVoltage.toFixed(1)}V`\n    });\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 980,
        "wires": [
            [
                "86faba0f81c2f696"
            ]
        ]
    }
]
